from __future__ import annotations

from typing import List, Optional, Tuple, Union
from abc import ABC, abstractmethod

import numpy as np
import pymc as pm

from coordination.common.types import TensorTypes
from coordination.module.parametrization2 import Parameter


class Module:

    def __init__(self):
        self.parameters: ModuleParameters = None

    @property
    def parameter_names(self) -> List[str]:
        """
        Gets the names of all the parameters used in the distributions of a latent variables.

        @return: a list with the parameter names.
        """
        return self.parameters.parameter_names

    def clear_parameter_values(self):
        """
        Clears the values of all the parameters. Their hyper-priors are preserved.
        """
        self.parameters.clear_values()

    @abstractmethod
    def draw_samples(self,
                     seed: Optional[int]) -> ModuleSamples:
        """
        Draws samples using ancestral sampling.

        @param seed: random seed for reproducibility.
        @return: samples.
        """
        pass

    @abstractmethod
    def update_pymc_model(
            self,
            pymc_model: pm.Model,
            observed_values: Optional[Dict[str, TensorTypes]] = None
    ) -> Dict[str, Union[TensorTypes, pm.Distribution], ...]:
        """
        Creates variables in a PyMC model. This function

        @param pymc_model: model definition in pymc.
        @param observed_values: observations for the non-parameter variables in the model. Values
            for the parameter variables are set directly in the module's parameters attribute. If a
            value is set, the variable is not latent anymore. The dictionary key indicated the uuid
            of the variable with observed values.
        @return: random variables added to the model indexed by their uuids.
        """
        pass


###################################################################################################
# AUXILIARY CLASSES
###################################################################################################


class ModuleParameters(ABC):
    """
    This class stores values and hyper-priors of the parameters of a module.
    """

    def clear_values(self):
        """
        Set values of the parameters to None. Parameters with None value will be fit to the data
        along with other latent values in the model.
        """
        attributes = vars(self)
        for _, parameter in attributes.items():
            if isinstance(parameter, Parameter):
                parameter.value = None

    @property
    def parameter_names(self) -> List[str]:
        """
        Gets a list of unique names of the distribution parameters in the module.

        @return: list of parameter names.
        """
        names = []
        attributes = vars(self)
        for _, parameter in attributes.items():
            if isinstance(parameter, Parameter):
                names.append(parameter.uuid)

        return names


class ModuleSamples(ABC):
    """
    This class stores samples generated by a module.
    """

    def __init__(self,
                 values: Union[List[np.ndarray], np.ndarray]):
        """
        Creates an object to store samples.

        @param values: sampled values of a module. For serial modules, this will be
            a list of time series of values of different sizes. For non-serial modules, this
            will be a tensor as the number of observations in time do not change for different
            sampled time series.
        """

        self.values = values

    @property
    def num_time_steps(self) -> Union[int, np.array]:
        """
        Gets the number of time steps
        @return: number of time steps.
        """

        if isinstance(self.values, List):
            # For a list of sampled series, they can have a different number of time steps. If
            # a scalar is returned, otherwise an array is returned with the number of time steps in
            # each individual series.
            sizes = np.array([sampled_series.shape[-1] for sampled_series in self.values])
            if len(sizes) == 0:
                return 0
            elif len(sizes) == 1:
                return sizes[0]
            else:
                return sizes
        else:
            return self.values.shape[-1]

    @property
    def num_series(self) -> int:
        """
        Gets the number of series.

        @return: number of series.
        """

        if isinstance(self.values, List):
            return len(self.values)
        else:
            return self.values.shape[0]
