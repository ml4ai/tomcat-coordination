from __future__ import annotations

from typing import List, Optional, Tuple, Union
from abc import ABC, abstractmethod

import numpy as np
import pymc as pm

from coordination.common.types import TensorTypes
from coordination.module.parametrization2 import Parameter


class Component:

    def __init__(self):
        self.parameters: ComponentParameters = None

    @property
    def parameter_names(self) -> List[str]:
        """
        Gets the names of all the parameters used in the distributions of a latent component.

        @return: a list with the parameter names.
        """
        return self.parameters.parameter_names

    def clear_parameter_values(self):
        """
        Clears the values of all the parameters. Their hyper-priors are preserved.
        """
        self.parameters.clear_values()

    @abstractmethod
    def draw_samples(self,
                     seed: Optional[int],
                     **kwargs) -> ComponentSamples:
        """
        Draws samples using ancestral sampling.

        @param seed: random seed for reproducibility.
        @param kwargs: extra arguments to be defined by subclasses.
        @return: samples.
        """
        pass

    @abstractmethod
    def update_pymc_model(self,
                          pymc_model: pm.Model,
                          **kwargs) -> Tuple[Union[TensorTypes, pm.Distribution], ...]:
        """
        Creates variables in a PyMC model. This function

        @param pymc_model: model definition in pymc.
        @param kwargs: extra parameters to be used by child classes.
        @return: random variables added to the model.
        """
        pass


###################################################################################################
# AUXILIARY CLASSES
###################################################################################################


class ComponentParameters(ABC):
    """
    This class stores values and hyper-priors of the parameters of a component.
    """

    def clear_values(self):
        """
        Set values of the parameters to None. Parameters with None value will be fit to the data
        along with other latent values in the model.
        """
        attributes = vars(self)
        for _, parameter in attributes.items():
            if isinstance(parameter, Parameter):
                parameter.value = None

    @property
    def parameter_names(self) -> List[str]:
        """
        Gets a list of unique names of the distribution parameters in the component.

        @return: list of parameter names.
        """
        names = []
        attributes = vars(self)
        for _, parameter in attributes.items():
            if isinstance(parameter, Parameter):
                names.append(parameter.uuid)

        return names


class ComponentSamples(ABC):
    """
    This class stores samples generated by a component.
    """

    def __init__(self,
                 values: Union[List[np.ndarray], np.ndarray]):
        """
        Creates an object to store samples.

        @param values: sampled values of a component. For serial components, this will be
            a list of time series of values of different sizes. For non-serial components, this
            will be a tensor as the number of observations in time do not change for different
            sampled time series.
        """

        self.values = values

    @property
    def num_time_steps(self) -> Union[int, np.array]:
        """
        Gets the number of time steps
        @return: number of time steps.
        """

        if isinstance(self.values, List):
            # For a list of sampled series, they can have a different number of time steps. If
            # a scalar is returned, otherwise an array is returned with the number of time steps in
            # each individual series.
            sizes = np.array([sampled_series.shape[-1] for sampled_series in self.values])
            if len(sizes) == 0:
                return 0
            elif len(sizes) == 1:
                return sizes[0]
            else:
                return sizes
        else:
            return self.values.shape[-1]

    @property
    def num_series(self) -> int:
        """
        Gets the number of series.

        @return: number of series.
        """

        if isinstance(self.values, List):
            return len(self.values)
        else:
            return self.values.shape[0]
